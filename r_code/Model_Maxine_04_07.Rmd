---
title: "Final Project"  
output: html_document 
date: "2025-04-05"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Overview
This Rmd attempts to recreate tables 2 and tables 3 from the paper solely for the BCF model. However, due to the long runtime, I have created a shorter version that calculates all four combinations (linear homogeneous, linear heterogeneous, nonlinear homogeneous, nonlinear heterogeneous), over 300 iterations, for n = 250 (not including n = 500) and just calculates RMSE (not including cover or length). 

This is the code for the shorter version:

```{r}
library(bcf)
library(dplyr)

set.seed(42)
nburn <- 100
nsim <- 200
n <- 250

mu_types <- c("linear", "nonlinear")
tau_types <- c("homogeneous", "heterogeneous")

results_list <- list()
idx <- 1

for (mu_type in mu_types) {
  for (tau_type in tau_types) {
    cat(sprintf("Running: mu = %s | tau = %s\n", mu_type, tau_type))

    tryCatch({
      X1 <- rnorm(n)
      X2 <- rnorm(n)
      X3 <- rnorm(n)
      X4 <- rbinom(n, 1, 0.5)
      X <- data.frame(X1, X2, X3, X4)

      # tau
      tau <- 1 + 2 * X$X2 * X$X4
      if (tau_type == "homogeneous") tau <- rep(3, n)

      # mu
      g_X4 <- ifelse(X$X4 == 1, 2, -1)
      mu <- if (mu_type == "linear") {
        1 + g_X4 + X$X1 * X$X3
      } else {
        -6 + g_X4 + 6 * abs(X$X3 - 1)
      }

      s_mu <- sd(mu)
      u <- runif(n)
      pi <- pnorm(0.8 * ((3 * mu / s_mu) - 0.5 * X$X1) + 0.05 + u / 10)
      pi <- pmax(0, pmin(1, pi))
      Z <- rbinom(n, 1, pi)

      eps <- rnorm(n)
      Y <- mu + tau * Z + eps

      X_mat <- as.matrix(X)
      fit <- bcf(y = Y, z = Z,
                 x_control = X_mat,
                 x_moderate = X_mat,
                 pihat = pi,
                 nburn = nburn,
                 nsim = nsim)

      tau_hat <- colMeans(fit$tau)
      ate_hat <- mean(tau_hat)

      rmse_ate <- sqrt(mean((ate_hat - tau)^2))
      rmse_cate <- sqrt(mean((tau_hat - tau)^2))

      results_list[[idx]] <- data.frame(
        mu_type = mu_type,
        tau_type = tau_type,
        rmse_ate = rmse_ate,
        rmse_cate = rmse_cate
      )
      idx <- idx + 1
    }, error = function(e) {
      cat("⚠️ Error in fitting BCF for this scenario\n")
    })
  }
}

results <- do.call(rbind, results_list)
print(results)
```

Starter to build the full for BCF: 

```{r}
# Load packages
library(bcf)
library(dplyr)

# Setup
set.seed(42)
num_rep <- 50
sample_sizes <- c(250)
tau_types <- c('homogeneous', 'heterogeneous')
mu_types <- c('linear', 'nonlinear')

results <- data.frame()

for (n in sample_sizes) {
  for (tau_type in tau_types) {
    for (mu_type in mu_types) {
      for (rep in 1:num_rep) {
        # Step 1: Generate covariates
        X1 <- rnorm(n)
        X2 <- rnorm(n)
        X3 <- rnorm(n)
        X4 <- rbinom(n, 1, 0.5)
        X <- data.frame(X1, X2, X3, X4)

        # Step 2: Treatment effect (tau)
        tau <- if (tau_type == "homogeneous") {
          rep(3, n)
        } else {
          1 + 2 * X$X2 * X$X4
        }

        # Step 3: Prognostic function (mu)
        g_X4 <- ifelse(X$X4 == 1, 2, -1)
        mu <- if (mu_type == "linear") {
          1 + g_X4 + X$X1 * X$X3
        } else {
          -6 + g_X4 + 6 * abs(X$X3 - 1)
        }

        # Step 4: Propensity score
        s_mu <- sd(mu)
        u <- runif(n)
        pi <- pnorm(0.8 * ((3 * mu / s_mu) - 0.5 * X$X1) + 0.05 + u / 10)
        pi <- pmax(0, pmin(1, pi))

        # Step 5: Treatment + Outcome
        Z <- rbinom(n, 1, pi)
        eps <- rnorm(n)
        Y <- mu + tau * Z + eps

        # Step 6: Fit BCF
        fit <- bcf(y = Y, z = Z, x_control = as.matrix(X), x_moderate = as.matrix(X),
                   pihat = pi, nburn = 500, nsim = 1000)

        # Step 7: Posterior summaries
        tau_samples <- fit$tau                     # nsim x n
        tau_hat <- colMeans(tau_samples)          # estimated CATEs
        ate_hat <- mean(tau_hat)                  # estimated ATE
        ate_true <- mean(tau)                     # true ATE

        # RMSE
        rmse_ate <- sqrt((ate_hat - ate_true)^2)
        rmse_cate <- sqrt(mean((tau_hat - tau)^2))

        # CATE 95% intervals
        lower <- apply(tau_samples, 2, quantile, probs = 0.025)
        upper <- apply(tau_samples, 2, quantile, probs = 0.975)
        coverage_cate <- mean((tau >= lower) & (tau <= upper))
        length_cate <- mean(upper - lower)

        # ATE 95% interval
        ate_samples <- rowMeans(tau_samples)
        ci_ate <- quantile(ate_samples, probs = c(0.025, 0.975))
        coverage_ate <- as.numeric(ate_true >= ci_ate[1] & ate_true <= ci_ate[2])
        length_ate <- ci_ate[2] - ci_ate[1]

        # Step 8: Save results
        results <- rbind(results, data.frame(
          rep, n, mu_type, tau_type,
          rmse_ate, rmse_cate,
          coverage_ate, coverage_cate,
          length_ate, length_cate
        ))
      }
    }
  }
}

# Summarize like Tables 2 & 3
summary_results <- results %>%
  group_by(mu_type, tau_type) %>%
  summarise(
    ATE_RMSE_mean = mean(rmse_ate),
    ATE_Coverage = mean(coverage_ate),
    ATE_Length = mean(length_ate),
    CATE_RMSE_mean = mean(rmse_cate),
    CATE_Coverage = mean(coverage_cate),
    CATE_Length = mean(length_cate),
    .groups = "drop"
  )

print(summary_results)
```


